name: Recovery Build

on:
  workflow_dispatch:
    inputs:
      SYNC_URL:
        description: 'SYNC_URL'
        required: true
        default: 'https://gitlab.com/OrangeFox/sync.git'
      MANIFEST_BRANCH:
        description: 'MANIFEST_BRANCH'
        required: true
        default: '9.0'
      DEVICE_TREE_URL:
        description: 'DEVICE_TREE_URL'
        required: true
        default: 'https://github.com/try-01/ofrp_device_realme_RMX1805'
      DEVICE_TREE_BRANCH:
        description: 'DEVICE_TREE_BRANCH'
        required: true
        default: 'fox_9.0_P'
      DEVICE_PATH:
        description: 'DEVICE_PATH'
        required: true
        default: 'device/realme/RMX1805'
      DEVICE_NAME:
        description: 'DEVICE_NAME'
        required: true
        default: 'RMX1805'
      MAKEFILE_NAME:
        description: 'MAKEFILE_NAME'
        required: true
        default: 'omni_RMX1805'
      BUILD_TARGET:
        description: 'BUILD_TARGET'
        required: true
        default: 'recovery'

jobs:
  build:
    if: github.event.repository.owner.id == github.event.sender.id
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
    - name: Check Out
      uses: actions/checkout@v4

    - name: Cleanup
      uses: rokibhasansagar/slimhub_actions@main

    - name: Initialize workspace
      run: |
        mkdir workspace
        cd workspace
        echo "workspace-folder=$(pwd)" >> $GITHUB_OUTPUT
      id: pwd

    - name: Set up JDK 8
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '8'

    - name: Force Git to use HTTPS for GitLab
      run: git config --global url."https://gitlab.com/".insteadOf "git@gitlab.com:"

    - name: Prepare the build environment
      run: |
        export JAVA_HOME=/usr/lib/jvm/temurin-8-jdk-amd64
        sudo apt install git aria2 -y
        git clone https://gitlab.com/OrangeFox/misc/scripts
        cd scripts
        sudo bash setup/android_build_env.sh
        sed -i 's/cd -/cd ../g' setup/install_android_sdk.sh
        sudo bash setup/install_android_sdk.sh
      working-directory: ${{ steps.pwd.outputs.workspace-folder }}

    - name: Sync OrangeFox sources and minimal manifest
      run: |
        cd ${{ steps.pwd.outputs.workspace-folder }}
        git clone ${{ github.event.inputs.SYNC_URL }}
        cd sync/legacy
        ./orangefox_sync_legacy.sh --branch ${{ github.event.inputs.MANIFEST_BRANCH }} --path ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}
      working-directory: ${{ steps.pwd.outputs.workspace-folder }}

    - name: Clone device tree
      run: |
        cd ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}
        git clone ${{ github.event.inputs.DEVICE_TREE_URL }} -b ${{ github.event.inputs.DEVICE_TREE_BRANCH }} ./${{ github.event.inputs.DEVICE_PATH }}
      working-directory: ${{ steps.pwd.outputs.workspace-folder }}

    - name: Set Swap Space
      uses: pierotofy/set-swap-space@master
      with:
        swap-size-gb: 12

    - name: Set up Python 2
      run: |
        sudo apt-get update
        sudo apt-get install -y python2
        sudo ln -sf /usr/bin/python2 /usr/bin/python
      continue-on-error: true

    - name: Apply Crypto Fixes (Manual Patching)
      run: |
        cd ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}
        
        echo "=== 1. Fixing Header Locations ==="
        mkdir -p system/security/keystore/include/keystore
        cp system/keymaster/include/keymaster/authorization_set.h system/security/keystore/include/keystore/
        cp system/keymaster/include/keymaster/keymaster_tags.h system/security/keystore/include/keystore/
        
        echo "=== 2. Patching Android.mk Files (Force KM 3.0) ==="
        # Patch fde/Android.mk
        sed -i '/^bool verify_package_compatibility(ZipWrap \*zw) {/,/^}/c bool verify_package_compatibility(ZipWrap *zw) { // NOLINT\n   (void)zw; // Mark parameter as intentionally unused\n   printf("OrangeFox: Forcefully bypassing Treble compatibility check via patch.\\n");\n   return true;\n}' "./bootable/recovery/installcommand.cpp"
        sed -i '21s/-ge 28/-ge 99/g' "./bootable/recovery/crypto/ext4crypt/Android.mk"
        sed -i '25s/-ge 28/-ge 99/g' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '80s/-ge 28/-ge 99/g' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '91d' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '36d' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '57,59d' "./bootable/recovery/crypto/ext4crypt/Android.mk"
        sed -i '34s/$/ -Wno-unused-variable -Wno-sign-compare -Wno-unused-parameter -Wno-comment/' "./bootable/recovery/crypto/ext4crypt/Android.mk"
        sed -i '10s|$| system/security system/security/keystore/include system/security/keystore system/keymaster/include hardware/libhardware/include/hardware|' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '68s|$| system/security system/security/keystore/include system/security/keystore system/keymaster/include hardware/libhardware/include/hardware|' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '36s|$| -Wno-unused-variable -Wno-sign-compare -Wno-unused-parameter -Wno-comment|' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '90s|$| -Wno-unused-variable -Wno-sign-compare -Wno-unused-parameter -Wno-comment|' "./bootable/recovery/crypto/fde/Android.mk"
        sed -i '11s|system/security/keystore|system/security system/security/keystore system/security/keystore/include|' "./bootable/recovery/crypto/ext4crypt/Android.mk"
        sed -i '34s|$| -Wno-unused-function|' "./bootable/recovery/crypto/ext4crypt/Android.mk"

        echo "=== 3. Overwriting C++ Source Files ==="
        
        # FIX Keymaster3.h (Namespace Fix)
        cat > bootable/recovery/crypto/ext4crypt/Keymaster3.h << 'EOF'
        #ifndef ANDROID_VOLD_KEYMASTER_H
        #define ANDROID_VOLD_KEYMASTER_H
        #ifdef __cplusplus
        #include <memory>
        #include <string>
        #include <utility>
        #include <android/hardware/keymaster/3.0/IKeymasterDevice.h>
        #include <keystore/authorization_set.h>
        #include "Utils.h"
        namespace android {
        namespace vold {
        using ::android::hardware::keymaster::V3_0::IKeymasterDevice;
        using ::keymaster::ErrorCode;
        using ::keymaster::KeyPurpose;
        using ::keymaster::AuthorizationSet;
        class KeymasterOperation {
          public:
            ~KeymasterOperation();
            explicit operator bool() { return mError == ErrorCode::OK; }
            ErrorCode errorCode() { return mError; }
            bool updateCompletely(const std::string& input, std::string* output);
            bool finish(std::string* output);
            KeymasterOperation(KeymasterOperation&& rhs) {
                mDevice = std::move(rhs.mDevice);
                mOpHandle = std::move(rhs.mOpHandle);
                mError = std::move(rhs.mError);
            }
            KeymasterOperation()
                : mDevice{nullptr}, mOpHandle{0}, mError {ErrorCode::UNKNOWN_ERROR} {}
            KeymasterOperation& operator= (KeymasterOperation&& rhs) {
                mDevice = std::move(rhs.mDevice);
                mOpHandle = std::move(rhs.mOpHandle);
                mError = std::move(rhs.mError);
                rhs.mError = ErrorCode::UNKNOWN_ERROR;
                rhs.mOpHandle = 0;
                return *this;
            }
          private:
            KeymasterOperation(const sp<IKeymasterDevice>& d, uint64_t h)
                : mDevice{d}, mOpHandle{h}, mError {ErrorCode::OK} {}
            KeymasterOperation(ErrorCode error)
                : mDevice{nullptr}, mOpHandle{0}, mError {error} {}
            sp<IKeymasterDevice> mDevice;
            uint64_t mOpHandle;
            ErrorCode mError;
            DISALLOW_COPY_AND_ASSIGN(KeymasterOperation);
            friend class Keymaster;
        };
        class Keymaster {
          public:
            Keymaster();
            explicit operator bool() { return mDevice.get() != nullptr; }
            bool deleteKey(const std::string& key);
            bool upgradeKey(const std::string& oldKey, const AuthorizationSet& inParams, std::string* newKey);
            KeymasterOperation begin(KeyPurpose purpose, const std::string& key, const AuthorizationSet& inParams, AuthorizationSet* outParams);
            bool isSecure();
          private:
            sp<hardware::keymaster::V3_0::IKeymasterDevice> mDevice;
            DISALLOW_COPY_AND_ASSIGN(Keymaster);
        };
        namespace dump {
        template<typename T> std::string toHexString(T t, bool prefix = true) {
            std::ostringstream os;
            if (prefix) { os << std::showbase; }
            os << std::hex << t;
            return os.str();
        }
        template<typename Array> std::string arrayToHexString(const Array &a, size_t size) {
            using android::hardware::toString;
            std::string os;
            for (size_t i = 0; i < size; ++i) os += toHexString(a[i]);
            return os;
        }
        template<typename T> std::string toString(const hardware::hidl_vec<T> &a) {
            std::string os;
            os += arrayToHexString(a, a.size());
            return os;
        }
        }
        }
        }
        #endif
        __BEGIN_DECLS
        int keymaster_sign_object_for_cryptfs_scrypt(const uint8_t* key_blob, size_t key_blob_size, uint32_t ratelimit, const uint8_t* object, const size_t object_size, uint8_t** signature_buffer, size_t* signature_buffer_size, uint8_t* key_buffer, uint32_t key_buffer_size, uint32_t* key_out_size);
        __END_DECLS
        #endif
        EOF

        # FIX Keymaster3.cpp
        cat > bootable/recovery/crypto/ext4crypt/Keymaster3.cpp << 'EOF'
        #include "Keymaster3.h"
        #include <keystore/keymaster_tags.h>
        #include <keystore/authorization_set.h>
        #include <keystore/keystore_hidl_support.h>
        #include <iostream>
        #define ERROR 1
        #define LOG(x) std::cout
        static const std::string kPkmBlob("pKMblob\x00", 8);
        using namespace ::keystore;
        using android::hardware::hidl_string;
        using android::hardware::hidl_vec;
        namespace android {
        namespace vold {
        KeymasterOperation::~KeymasterOperation() { if (mDevice.get()) mDevice->abort(mOpHandle); }
        bool KeymasterOperation::updateCompletely(const std::string& input, std::string* output) {
            if (output) output->clear();
            auto it = input.begin();
            uint32_t inputConsumed;
            ErrorCode km_error;
            auto hidlCB = [&] (ErrorCode ret, uint32_t _inputConsumed, const hidl_vec<KeyParameter>&, const hidl_vec<uint8_t>& _output) {
                km_error = ret;
                if (km_error != ErrorCode::OK) return;
                inputConsumed = _inputConsumed;
                if (output) output->append(reinterpret_cast<const char*>(&_output[0]), _output.size());
            };
            while (it != input.end()) {
                size_t toRead = static_cast<size_t>(input.end() - it);
                auto inputBlob = blob2hidlVec(reinterpret_cast<const uint8_t*>(&*it), toRead);
                auto error = mDevice->update(mOpHandle, hidl_vec<KeyParameter>(), inputBlob, hidlCB);
                if (!error.isOk() || km_error != ErrorCode::OK) { mDevice = nullptr; return false; }
                if (inputConsumed > toRead) { mDevice = nullptr; return false; }
                it += inputConsumed;
            }
            return true;
        }
        bool KeymasterOperation::finish(std::string* output) {
            ErrorCode km_error;
            auto hidlCb = [&] (ErrorCode ret, const hidl_vec<KeyParameter>&, const hidl_vec<uint8_t>& _output) {
                km_error = ret;
                if (km_error != ErrorCode::OK) return;
                if (output) output->assign(reinterpret_cast<const char*>(&_output[0]), _output.size());
            };
            auto error = mDevice->finish(mOpHandle, hidl_vec<KeyParameter>(), hidl_vec<uint8_t>(), hidl_vec<uint8_t>(), hidlCb);
            mDevice = nullptr;
            return (error.isOk() && km_error == ErrorCode::OK);
        }
        Keymaster::Keymaster() { mDevice = ::android::hardware::keymaster::V3_0::IKeymasterDevice::getService(); }
        bool Keymaster::deleteKey(const std::string&) { return false; }
        bool Keymaster::upgradeKey(const std::string& oldKey, const AuthorizationSet& inParams, std::string* newKey) {
            auto oldKeyBlob = blob2hidlVec(oldKey);
            ErrorCode km_error;
            auto hidlCb = [&] (ErrorCode ret, const hidl_vec<uint8_t>& upgradedKeyBlob) {
                km_error = ret;
                if (km_error != ErrorCode::OK) return;
                if (newKey) newKey->assign(reinterpret_cast<const char*>(&upgradedKeyBlob[0]), upgradedKeyBlob.size());
            };
            auto error = mDevice->upgradeKey(oldKeyBlob, keystore::authorizationSetToHidl(inParams), hidlCb);
            return (error.isOk() && km_error == ErrorCode::OK);
        }
        KeymasterOperation Keymaster::begin(KeyPurpose purpose, const std::string& key, const AuthorizationSet& inParams, AuthorizationSet* outParams) {
            auto keyBlob = blob2hidlVec(key);
            uint64_t mOpHandle;
            ErrorCode km_error;
            auto hidlCb = [&] (ErrorCode ret, const hidl_vec<KeyParameter>& _outParams, uint64_t operationHandle) {
                km_error = ret;
                if (km_error != ErrorCode::OK) return;
                if (outParams) *outParams = _outParams;
                mOpHandle = operationHandle;
            };
            std::string kmKey = dump::toString(keyBlob);
            if (!kmKey.compare(0, kPkmBlob.size(), kPkmBlob)) { kmKey.erase(0, kPkmBlob.size()); keyBlob = blob2hidlVec(kmKey); }
            auto error = mDevice->begin(purpose, keyBlob, keystore::authorizationSetToHidl(inParams), hidlCb);
            if (!error.isOk() || km_error != ErrorCode::OK) return KeymasterOperation(km_error);
            return KeymasterOperation(mDevice, mOpHandle);
        }
        bool Keymaster::isSecure() {
            bool _isSecure = false;
            auto rc = mDevice->getHardwareFeatures([&] (bool isSecure, bool, bool, bool, bool, const hidl_string&, const hidl_string&) { _isSecure = isSecure; });
            return rc.isOk() && _isSecure;
        }
        }
        }
        using namespace ::android::vold;
        int keymaster_sign_object_for_cryptfs_scrypt(const uint8_t* key_blob, size_t key_blob_size, uint32_t ratelimit, const uint8_t* object, const size_t object_size, uint8_t** signature_buffer, size_t* signature_buffer_size, uint8_t* key_buffer, uint32_t key_buffer_size, uint32_t* key_out_size) {
            Keymaster dev;
            if (!dev) return -1;
            AuthorizationSet outParams;
            std::string key(reinterpret_cast<const char*>(key_blob), key_blob_size);
            std::string input(reinterpret_cast<const char*>(object), object_size);
            std::string output;
            KeymasterOperation op;
            AuthorizationSet paramBuilder;
            paramBuilder.push_back(TAG_PADDING, PaddingMode::NONE);
            paramBuilder.push_back(TAG_DIGEST, Digest::NONE);
            while (true) {
                op = dev.begin(KeyPurpose::SIGN, key, paramBuilder, &outParams);
                if (op.errorCode() == ErrorCode::KEY_RATE_LIMIT_EXCEEDED) { sleep(ratelimit); continue; }
                else if (op.errorCode() == ErrorCode::KEY_REQUIRES_UPGRADE) {
                    std::string newKey;
                    if (!dev.upgradeKey(key, paramBuilder, &newKey)) return -1;
                    if (key_out_size) *key_out_size = newKey.size();
                    if (key_buffer_size < newKey.size()) return -1;
                    std::copy(newKey.data(), newKey.data() + newKey.size(), key_buffer);
                    key = newKey;
                } else break;
            }
            if (op.errorCode() != ErrorCode::OK) return -1;
            if (!op.updateCompletely(input, &output)) return -1;
            if (!op.finish(&output)) return -1;
            *signature_buffer = reinterpret_cast<uint8_t*>(malloc(output.size()));
            if (*signature_buffer == nullptr) return -1;
            *signature_buffer_size = output.size();
            std::copy(output.data(), output.data() + output.size(), *signature_buffer);
            return 0;
        }
        EOF

        # FIX KeyStorage3.cpp
        cat > bootable/recovery/crypto/ext4crypt/KeyStorage3.cpp << 'EOF'
        #include "KeyStorage3.h"
        #include "Keymaster3.h"
        #include "ScryptParameters.h"
        #include "Utils.h"
        #include <vector>
        #include <errno.h>
        #include <stdio.h>
        #include <sys/stat.h>
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <unistd.h>
        #include <openssl/err.h>
        #include <openssl/evp.h>
        #include <openssl/sha.h>
        #include <android-base/file.h>
        #include <android-base/logging.h>
        #include <cutils/properties.h>
        #include <hardware/hw_auth_token.h>
        #include <keystore/authorization_set.h>
        #include <keystore/keymaster_tags.h>
        #include <keystore/keystore_hidl_support.h>
        extern "C" {
        #include "crypto_scrypt.h"
        }
        #include <iostream>
        #define ERROR 1
        using android::hardware::keymaster::V3_0::KeyFormat;
        using android::hardware::keymaster::V3_0::KeyParameter;
        using KeystoreAuthorizationSet = ::keymaster::AuthorizationSet;
        using KeystoreErrorCode = ::keymaster::ErrorCode;
        namespace android {
        namespace vold {
        const KeyAuthentication kEmptyAuthentication{"", ""};
        static constexpr size_t AES_KEY_BYTES = 32;
        static constexpr size_t GCM_NONCE_BYTES = 12;
        static constexpr size_t GCM_MAC_BYTES = 16;
        static constexpr size_t SALT_BYTES = 1 << 4;
        static constexpr size_t SECDISCARDABLE_BYTES = 1 << 14;
        static constexpr size_t STRETCHED_BYTES = 1 << 6;
        static constexpr uint32_t AUTH_TIMEOUT = 30;
        static const char* kCurrentVersion = "1";
        static const char* kRmPath = "/system/bin/rm";
        static const char* kSecdiscardPath = "/system/bin/secdiscard";
        static const char* kStretch_none = "none";
        static const char* kStretch_nopassword = "nopassword";
        static const std::string kStretchPrefix_scrypt = "scrypt ";
        static const char* kHashPrefix_secdiscardable = "Android secdiscardable SHA512";
        static const char* kHashPrefix_keygen = "Android key wrapping key generation SHA512";
        static const char* kFn_encrypted_key = "encrypted_key";
        static const char* kFn_keymaster_key_blob = "keymaster_key_blob";
        static const char* kFn_keymaster_key_blob_upgraded = "keymaster_key_blob_upgraded";
        static const char* kFn_salt = "salt";
        static const char* kFn_secdiscardable = "secdiscardable";
        static const char* kFn_stretching = "stretching";
        static const char* kFn_version = "version";
        static bool checkSize(const std::string& kind, size_t actual, size_t expected) {
            if (actual != expected) {
                LOG(ERROR) << "Wrong number of bytes in " << kind << ", expected " << expected << " got " << actual;
                return false;
            }
            return true;
        }
        static std::string hashWithPrefix(char const* prefix, const std::string& tohash) {
            SHA512_CTX c;
            SHA512_Init(&c);
            std::string hashingPrefix = prefix;
            hashingPrefix.resize(SHA512_CBLOCK);
            SHA512_Update(&c, hashingPrefix.data(), hashingPrefix.size());
            SHA512_Update(&c, tohash.data(), tohash.size());
            std::string res(SHA512_DIGEST_LENGTH, '\0');
            SHA512_Final(reinterpret_cast<uint8_t*>(&res[0]), &c);
            return res;
        }
        static KeystoreAuthorizationSet beginParams(const KeyAuthentication& auth, const std::string& appId) {
            KeystoreAuthorizationSet params;
            params.push_back(::keymaster::TAG_BLOCK_MODE, ::keymaster::KM_MODE_GCM);
            params.push_back(::keymaster::TAG_MAC_LENGTH, GCM_MAC_BYTES * 8);
            params.push_back(::keymaster::TAG_PADDING, ::keymaster::KM_PAD_NONE);
            ::keymaster::keymaster_blob_t appIdBlob = { (uint8_t*)appId.data(), appId.size() };
            params.push_back(::keymaster::TAG_APPLICATION_ID, appIdBlob);
            if (!auth.token.empty()) {
                ::keymaster::keymaster_blob_t authBlob = { (uint8_t*)auth.token.data(), auth.token.size() };
                params.push_back(::keymaster::TAG_AUTH_TOKEN, authBlob);
            }
            return params;
        }
        static bool readFileToString(const std::string& filename, std::string* result) {
            if (!android::base::ReadFileToString(filename, result)) { PLOG(ERROR) << "Failed to read from " << filename; return false; }
            return true;
        }
        static bool writeStringToFile(const std::string& payload, const std::string& filename) {
            if (!android::base::WriteStringToFile(payload, filename)) { PLOG(ERROR) << "Failed to write to " << filename; return false; }
            return true;
        }
        static KeymasterOperation begin(Keymaster& keymaster, const std::string& dir, ::keymaster::KeyPurpose purpose, const KeystoreAuthorizationSet &keyParams, const KeystoreAuthorizationSet &opParams, KeystoreAuthorizationSet* outParams) {
            auto kmKeyPath = dir + "/" + kFn_keymaster_key_blob;
            std::string kmKey;
            if (!readFileToString(kmKeyPath, &kmKey)) return KeymasterOperation();
            KeystoreAuthorizationSet inParams(keyParams);
            inParams.append(opParams.begin(), opParams.end());
            for (;;) {
                auto opHandle = keymaster.begin((android::hardware::keymaster::V3_0::KeyPurpose)purpose, kmKey, inParams, outParams);
                if (opHandle) return opHandle;
                if (opHandle.errorCode() != KeystoreErrorCode::KEY_REQUIRES_UPGRADE) return opHandle;
                LOG(DEBUG) << "Upgrading key: " << dir;
                std::string newKey;
                KeystoreAuthorizationSet paramCopy(keyParams);
                if (!keymaster.upgradeKey(kmKey, paramCopy, &newKey)) return KeymasterOperation();
                kmKey = newKey;
                LOG(INFO) << "Key upgraded: " << dir;
            }
        }
        static bool decryptWithKeymasterKey(Keymaster& keymaster, const std::string& dir, const KeystoreAuthorizationSet &keyParams, const std::string& ciphertext, std::string* message) {
            auto nonce = ciphertext.substr(0, GCM_NONCE_BYTES);
            auto bodyAndMac = ciphertext.substr(GCM_NONCE_BYTES);
            KeystoreAuthorizationSet opParams;
            ::keymaster::keymaster_blob_t nonceBlob = { (uint8_t*)nonce.data(), nonce.size() };
            opParams.push_back(::keymaster::TAG_NONCE, nonceBlob);
            auto opHandle = begin(keymaster, dir, ::keymaster::KM_PURPOSE_DECRYPT, keyParams, opParams, nullptr);
            if (!opHandle) return false;
            if (!opHandle.updateCompletely(bodyAndMac, message)) return false;
            if (!opHandle.finish(nullptr)) return false;
            return true;
        }
        static std::string getStretching(const KeyAuthentication& auth) {
            if (!auth.usesKeymaster()) return kStretch_none;
            else if (auth.secret.empty()) return kStretch_nopassword;
            else {
                char paramstr[PROPERTY_VALUE_MAX];
                property_get(SCRYPT_PROP, paramstr, SCRYPT_DEFAULTS);
                return std::string() + kStretchPrefix_scrypt + paramstr;
            }
        }
        static bool stretchingNeedsSalt(const std::string& stretching) {
            return stretching != kStretch_nopassword && stretching != kStretch_none;
        }
        static bool stretchSecret(const std::string& stretching, const std::string& secret, const std::string& salt, std::string* stretched) {
            if (stretching == kStretch_nopassword) {
                if (!secret.empty()) LOG(WARNING) << "Password present but stretching is nopassword";
                stretched->clear();
            } else if (stretching == kStretch_none) {
                *stretched = secret;
            } else if (std::equal(kStretchPrefix_scrypt.begin(), kStretchPrefix_scrypt.end(), stretching.begin())) {
                int Nf, rf, pf;
                if (!parse_scrypt_parameters(stretching.substr(kStretchPrefix_scrypt.size()).c_str(), &Nf, &rf, &pf)) return false;
                stretched->assign(STRETCHED_BYTES, '\0');
                if (crypto_scrypt(reinterpret_cast<const uint8_t*>(secret.data()), secret.size(), reinterpret_cast<const uint8_t*>(salt.data()), salt.size(), 1 << Nf, 1 << rf, 1 << pf, reinterpret_cast<uint8_t*>(&(*stretched)[0]), stretched->size()) != 0) return false;
            } else { LOG(ERROR) << "Unknown stretching type: " << stretching; return false; }
            return true;
        }
        static bool generateAppId(const KeyAuthentication& auth, const std::string& stretching, const std::string& salt, const std::string& secdiscardable, std::string* appId) {
            std::string stretched;
            if (!stretchSecret(stretching, auth.secret, salt, &stretched)) return false;
            *appId = hashWithPrefix(kHashPrefix_secdiscardable, secdiscardable) + stretched;
            return true;
        }
        static bool readRandomBytesOrLog(size_t count, std::string* out) {
            auto status = ReadRandomBytes(count, *out);
            if (status != OK) { LOG(ERROR) << "Random read failed"; return false; }
            return true;
        }
        static void logOpensslError() { LOG(ERROR) << "Openssl error: " << ERR_get_error(); }
        static bool encryptWithoutKeymaster(const std::string& preKey, const std::string& plaintext, std::string* ciphertext) {
            auto key = hashWithPrefix(kHashPrefix_keygen, preKey);
            key.resize(AES_KEY_BYTES);
            if (!readRandomBytesOrLog(GCM_NONCE_BYTES, ciphertext)) return false;
            auto ctx = std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free);
            if (!ctx) return false;
            if (1 != EVP_EncryptInit_ex(ctx.get(), EVP_aes_256_gcm(), NULL, reinterpret_cast<const uint8_t*>(key.data()), reinterpret_cast<const uint8_t*>(ciphertext->data()))) return false;
            ciphertext->resize(GCM_NONCE_BYTES + plaintext.size() + GCM_MAC_BYTES);
            int outlen;
            if (1 != EVP_EncryptUpdate(ctx.get(), reinterpret_cast<uint8_t*>(&(*ciphertext)[0] + GCM_NONCE_BYTES), &outlen, reinterpret_cast<const uint8_t*>(plaintext.data()), plaintext.size())) return false;
            if (1 != EVP_EncryptFinal_ex(ctx.get(), reinterpret_cast<uint8_t*>(&(*ciphertext)[0] + GCM_NONCE_BYTES + plaintext.size()), &outlen)) return false;
            if (1 != EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_GET_TAG, GCM_MAC_BYTES, reinterpret_cast<uint8_t*>(&(*ciphertext)[0] + GCM_NONCE_BYTES + plaintext.size()))) return false;
            return true;
        }
        static bool decryptWithoutKeymaster(const std::string& preKey, const std::string& ciphertext, std::string* plaintext) {
            if (ciphertext.size() < GCM_NONCE_BYTES + GCM_MAC_BYTES) return false;
            auto key = hashWithPrefix(kHashPrefix_keygen, preKey);
            key.resize(AES_KEY_BYTES);
            auto ctx = std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free);
            if (!ctx) return false;
            if (1 != EVP_DecryptInit_ex(ctx.get(), EVP_aes_256_gcm(), NULL, reinterpret_cast<const uint8_t*>(key.data()), reinterpret_cast<const uint8_t*>(ciphertext.data()))) return false;
            plaintext->resize(ciphertext.size() - GCM_NONCE_BYTES - GCM_MAC_BYTES);
            int outlen;
            if (1 != EVP_DecryptUpdate(ctx.get(), reinterpret_cast<uint8_t*>(&(*plaintext)[0]), &outlen, reinterpret_cast<const uint8_t*>(ciphertext.data() + GCM_NONCE_BYTES), plaintext->size())) return false;
            if (1 != EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_SET_TAG, GCM_MAC_BYTES, const_cast<void *>(reinterpret_cast<const void*>(ciphertext.data() + GCM_NONCE_BYTES + plaintext->size())))) return false;
            if (1 != EVP_DecryptFinal_ex(ctx.get(), reinterpret_cast<uint8_t*>(&(*plaintext)[0] + plaintext->size()), &outlen)) return false;
            return true;
        }
        bool retrieveKey(const std::string& dir, const KeyAuthentication& auth, std::string* key) {
            std::string version;
            if (!readFileToString(dir + "/" + kFn_version, &version)) return false;
            if (version != kCurrentVersion) return false;
            std::string secdiscardable;
            if (!readFileToString(dir + "/" + kFn_secdiscardable, &secdiscardable)) return false;
            std::string stretching;
            if (!readFileToString(dir + "/" + kFn_stretching, &stretching)) return false;
            std::string salt;
            if (stretchingNeedsSalt(stretching)) { if (!readFileToString(dir + "/" + kFn_salt, &salt)) return false; }
            std::string appId;
            if (!generateAppId(auth, stretching, salt, secdiscardable, &appId)) return false;
            std::string encryptedMessage;
            if (!readFileToString(dir + "/" + kFn_encrypted_key, &encryptedMessage)) return false;
            if (auth.usesKeymaster()) {
                Keymaster keymaster;
                if (!keymaster) return false;
                auto keyParams = beginParams(auth, appId);
                if (!decryptWithKeymasterKey(keymaster, dir, keyParams, encryptedMessage, key)) return false;
            } else {
                if (!decryptWithoutKeymaster(appId, encryptedMessage, key)) return false;
            }
            return true;
        }
        static bool deleteKey(const std::string& dir) {
            std::string kmKey;
            if (!readFileToString(dir + "/" + kFn_keymaster_key_blob, &kmKey)) return false;
            Keymaster keymaster;
            if (!keymaster) return false;
            if (!keymaster.deleteKey(kmKey)) return false;
            return true;
        }
        static bool runSecdiscard(const std::string& dir) {
            if (ForkExecvp(std::vector<std::string>{kSecdiscardPath, "--", dir + "/" + kFn_encrypted_key, dir + "/" + kFn_keymaster_key_blob, dir + "/" + kFn_secdiscardable}) != 0) return false;
            return true;
        }
        bool runSecdiscardSingle(const std::string& file) {
            if (ForkExecvp(std::vector<std::string>{kSecdiscardPath, "--", file}) != 0) return false;
            return true;
        }
        static bool recursiveDeleteKey(const std::string& dir) {
            if (ForkExecvp(std::vector<std::string>{kRmPath, "-rf", dir}) != 0) return false;
            return true;
        }
        bool destroyKey(const std::string& dir) {
            bool success = true;
            success &= deleteKey(dir);
            success &= runSecdiscard(dir);
            success &= recursiveDeleteKey(dir);
            return success;
        }
        }
        }
        EOF
      working-directory: ${{ steps.pwd.outputs.workspace-folder }}

    - name: Build recovery
      run: |
        cd ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}
        set +e
        source build/envsetup.sh
        export ALLOW_MISSING_DEPENDENCIES=true
        set -e
        lunch ${{ github.event.inputs.MAKEFILE_NAME }}-eng
        make clean && mka ${{ github.event.inputs.BUILD_TARGET }}image -j$(nproc --all)
      working-directory: ${{ steps.pwd.outputs.workspace-folder }}

    - name: Check the output directory before uploading
      run: |
        ls -al ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}/out/target/product/
        echo
        ls -al ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}/out/target/product/${{ github.event.inputs.DEVICE_NAME }}/

    - name: Upload to Release
      uses: softprops/action-gh-release@v2
      with:
        files: |
          ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}/out/target/product/${{ github.event.inputs.DEVICE_NAME }}/*.img
          ${{ steps.pwd.outputs.workspace-folder }}/fox_${{ github.event.inputs.MANIFEST_BRANCH }}/out/target/product/${{ github.event.inputs.DEVICE_NAME }}/*.zip
        name: ${{ github.event.inputs.DEVICE_NAME }}-${{ github.run_id }}
        tag_name: ${{ github.run_id }}
        body: |
          Manifest: ${{ github.event.inputs.MANIFEST_BRANCH }}
          Device: ${{ github.event.inputs.DEVICE_NAME }}
          Target: ${{ github.event.inputs.BUILD_TARGET }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
